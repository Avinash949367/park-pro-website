
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parking Path Map</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f0f0f0;
      margin: 0;
      padding: 20px;
      text-align: center;
    }

    h1 {
      color: #333;
    }

    .button-group {
      margin: 20px auto;
    }

    .button-group button {
      padding: 10px 18px;
      margin: 6px;
      font-size: 15px;
      border: none;
      border-radius: 5px;
      background-color: #1976d2;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .button-group button:hover {
      background-color: #1565c0;
    }

    .map-wrapper {
      position: relative;
      width: 900px;
      height: 600px;
      margin: 0 auto;
      overflow: hidden;
      border: 1px solid #ccc;
    }

    .map-img {
      position: absolute;
      left: 0;
      top: 0;
      width: 900px;
      height: 600px;
      display: block;
      transform-origin: center;
      transition: transform 0.2s ease-out;
    }

    #mapCanvas {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 10;
      transition: transform 0.2s ease-out;
    }

    .zoom-controls {
      margin: 10px auto;
      text-align: center;
    }

    .zoom-controls button {
      padding: 10px;
      margin: 0 5px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      background-color: #1976d2;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .zoom-controls button:hover {
      background-color: #1565c0;
    }
  </style>
</head>
<body>

  <h1>Interactive Parking Path Map</h1>

  <div class="button-group">
    <label for="sourceInput">Source:</label>
    <input type="text" id="sourceInput" list="sourceOptions" value="start" />
    <datalist id="sourceOptions">
      <option value="start"></option>
      <option value="s1"></option>
      <option value="s2"></option>
      <option value="s3"></option>
      <option value="s4"></option>
    </datalist>

    <label for="destinationInput">Destination:</label>
    <input type="text" id="destinationInput" list="destinationOptions" value="exit" />
    <datalist id="destinationOptions">
      <option value="exit"></option>
    </datalist>

    <button onclick="drawPathFromInput()">Show Path</button>
  </div>

  <div class="map-wrapper">
    <img src="p2.png" class="map-img" id="mapImage" />
    <canvas id="mapCanvas" width="900" height="600"></canvas>
  </div>

  <div class="zoom-controls">
    <button id="zoomIn">+</button>
    <button id="zoomOut">-</button>
    <button id="resetView">Reset View</button>
  </div>

  <script>
    const canvas = document.getElementById("mapCanvas");
    const ctx = canvas.getContext("2d");
    const img = document.getElementById("mapImage");

    // Variables for pan and zoom
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let rotation = 0;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let currentFrom = null;
    let currentTo = null;
    let firstDraw = true;

    // Approximate coordinates of points based on your image
    const positions = {
      start: { x: 100, y: 70 },
      exit: { x: 825, y: 540 },
      p1: { x: 100, y: 540 },
      p2: { x: 450, y: 540 },
      p3: { x: 450, y: 405 },
      p4: { x: 450, y: 160 },
      s1: { x: 320, y: 160 },
      s2: { x: 320, y: 405 },
      s3: { x: 580, y: 405 },
      s4: { x: 580, y: 160 }
    };

    function drawYouAreHere(pos) {
      // Draw a blue circle with a lighter blue outer glow to mimic the Google Maps location icon
      const outerRadius = 20;
      const innerRadius = 8;

      // Outer glow
      const gradient = ctx.createRadialGradient(
        pos.x,
        pos.y,
        innerRadius,
        pos.x,
        pos.y,
        outerRadius
      );
      gradient.addColorStop(0, 'rgba(66, 133, 244, 0.6)');
      gradient.addColorStop(1, 'rgba(66, 133, 244, 0)');

      ctx.beginPath();
      ctx.fillStyle = gradient;
      ctx.arc(pos.x, pos.y, outerRadius, 0, 2 * Math.PI);
      ctx.fill();

      // Inner solid circle
      ctx.beginPath();
      ctx.fillStyle = '#4285F4'; // Google blue
      ctx.arc(pos.x, pos.y, innerRadius, 0, 2 * Math.PI);
      ctx.fill();

      // Inner white circle
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.arc(pos.x, pos.y, innerRadius / 2, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawDestinationIcon(pos) {
      // Draw a red circle
      ctx.beginPath();
      ctx.fillStyle = "red";
      ctx.arc(pos.x, pos.y, 15, 0, 2 * Math.PI);
      ctx.fill();

      // Draw a white checkmark
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText("✓", pos.x - 5, pos.y + 5);
    }

    const paths = {
      "start-s1": ["start", "p1", "p2", "p3", "p4", "s1"],
      "start-s2": ["start", "p1", "p2", "p3", "s2"],
      "start-s3": ["start", "p1", "p2", "p3", "s3"],
      "start-s4": ["start", "p1", "p2", "p3", "p4", "s4"],
      "start-exit": ["start", "p1", "p2", "exit"],

      "s1-exit": ["s1", "p4", "p3", "p2", "exit"],
      "s2-exit": ["s2", "p3", "p2", "exit"],
      "s3-exit": ["s3", "p3", "p2", "exit"],
      "s4-exit": ["s4", "p4", "p3", "p2", "exit"]
    };

    function centerViewOnPoint(point) {
      scale = 2;
      offsetX = canvas.width / 2 - point.x;
      offsetY = canvas.height / 2 - point.y;
    }

    function updateTransforms() {
      scale = Math.max(1, Math.min(3, scale));
      const minOffsetX = - (scale - 1) * 450;
      const maxOffsetX = (scale - 1) * 450;
      offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
      const minOffsetY = - (scale - 1) * 300;
      const maxOffsetY = (scale - 1) * 300;
      offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
      const transform = 'scale(' + scale + ') translate(' + offsetX + 'px, ' + offsetY + 'px) rotate(' + rotation + 'rad)';
      img.style.transform = transform;
      canvas.style.transform = transform;
    }

    function redraw() {
      if (currentFrom && currentTo) {
        drawPath(currentFrom, currentTo);
      }
    }

    function drawPath(from, to) {
      const key = `${from}-${to}`;
      const path = paths[key];

      if (!path) {
        alert("No path found!");
        return;
      }

      currentFrom = from;
      currentTo = to;

      // Remove centering on source to prevent screen move on click search
      // if (firstDraw) {
      //   centerViewOnPoint(positions[from]);
      //   firstDraw = false;
      // }

      updateTransforms();

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#1976d2";
      ctx.lineWidth = 30;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      for (let i = 0; i < path.length - 1; i++) {
        const a = positions[path[i]];
        const b = positions[path[i + 1]];
        // Use cubic Bezier curve control points for smooth rounded corners
        const cp1X = a.x;
        const cp1Y = (a.y + b.y) / 2;
        const cp2X = b.x;
        const cp2Y = (a.y + b.y) / 2;

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.bezierCurveTo(
          cp1X,
          cp1Y,
          cp2X,
          cp2Y,
          b.x,
          b.y
        );
        ctx.stroke();

        // Draw direction text for horizontal or vertical segments
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        let direction = "";
        if (Math.abs(dx) > Math.abs(dy)) {
          direction = dx > 0 ? "→" : "←";
        } else if (Math.abs(dy) > Math.abs(dx)) {
          direction = dy > 0 ? "↓" : "↑";
        }
        if (direction) {
          const midX = (a.x + b.x) / 2;
          const midY = (a.y + b.y) / 2;
          ctx.font = "18px Arial";
          ctx.fillStyle = "white";
          ctx.fillText(direction, midX - 10, midY + 10);
        }

        // Draw arrow slightly offset from the curve end for better visual
        const angle = Math.atan2(b.y - cp2Y, b.x - cp2X);
        const arrowPos = { x: b.x - 15 * Math.cos(angle), y: b.y - 15 * Math.sin(angle) };
        drawArrow({ x: arrowPos.x, y: arrowPos.y }, angle);
      }

      // Draw "You're here" at the starting point of the path
      drawYouAreHere(positions[from]);

      // Draw destination icon at the destination point
      drawDestinationIcon(positions[to]);
    }

    function drawArrow(pos, angle) {
      const headlen = 15;
      const x = pos.x;
      const y = pos.y;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-headlen, -headlen / 2);
      ctx.lineTo(-headlen, headlen / 2);
      ctx.closePath();
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.restore();
    }

    // Event listeners for pan and zoom
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (e.shiftKey) {
        // Rotate with shift + wheel
        rotation += e.deltaY > 0 ? 0.1 : -0.1;
        updateTransforms();
      } else {
        // Zoom normally
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        scale *= zoomFactor;
        updateTransforms();
        redraw();
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStart = { x: e.offsetX, y: e.offsetY };
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        offsetX += (e.offsetX - dragStart.x) / scale;
        offsetY += (e.offsetY - dragStart.y) / scale;
        dragStart = { x: e.offsetX, y: e.offsetY };
        updateTransforms();
        redraw();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Zoom controls
    document.getElementById('zoomIn').addEventListener('click', () => {
      scale *= 1.2;
      updateTransforms();
      redraw();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      scale *= 0.8;
      updateTransforms();
      redraw();
    });

    document.getElementById('resetView').addEventListener('click', () => {
      scale = 1;
      offsetX = 0;
      offsetY = 0;
      rotation = 0;
      updateTransforms();
      redraw();
    });

    document.getElementById('rotateLeft').addEventListener('click', () => {
      rotation -= Math.PI / 8; // Rotate 22.5 degrees left
      updateTransforms();
      redraw();
    });

    document.getElementById('rotateRight').addEventListener('click', () => {
      rotation += Math.PI / 8; // Rotate 22.5 degrees right
      updateTransforms();
      redraw();
    });


  </script>

  <script>
    function drawPathFromInput() {
      const source = document.getElementById('sourceInput').value.trim();
      const destination = document.getElementById('destinationInput').value.trim();

      // Validate inputs
      const validSources = ['start', 's1', 's2', 's3', 's4', 'exit'];
      const validDestinations = ['exit', 's1', 's2', 's3', 's4', ];

      if (!validSources.includes(source)) {
        alert('Invalid source. Valid options: ' + validSources.join(', '));
        return;
      }
      if (!validDestinations.includes(destination)) {
        alert('Invalid destination. Valid options: ' + validDestinations.join(', '));
        return;
      }

      firstDraw = true;
      drawPath(source, destination);
    }

    function updateTransformsWithRotation() {
      scale = Math.max(1, Math.min(3, scale));
      const minOffsetX = - (scale - 1) * 450;
      const maxOffsetX = (scale - 1) * 450;
      offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
      const minOffsetY = - (scale - 1) * 300;
      const maxOffsetY = (scale - 1) * 300;
      offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
      const transform = 'scale(' + scale + ') translate(' + offsetX + 'px, ' + offsetY + 'px) rotate(' + rotation + 'rad)';
      img.style.transform = transform;
      canvas.style.transform = transform;
    }
  </script>
</body>
</html>
